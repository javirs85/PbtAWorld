@using PbtALib;
@inject USGameController Game
@inject USMovesService Moves
@inject MoveSelector.MoveSelectorService MSelector
@inject IToastService Toaster

<div class="PbtASystemContainer @(IsSelected?"IsSelected":"Innactive") @(IsSelectionMode?"ShowFull":"")" 
	@onclick=PointerDown
	@oncontextmenu:preventDefault=true 
	@oncontextmenu:stopPropagation=true>
	<div class="Box">
		<div class="TextContainer">
			<div class="TextTitle">@Move.Title</div>
			@if (Move.HasRoll() && !MasterView)
			{
				@if(Move.Rolls.Count > 4 || IsRollMixed(Move.Rolls))
				{
					<div class="RollDetails">(Mix)</div>
				}
				else if(Move.Roll == USAttributes.MortalityStatus || Move.Roll == USAttributes.NightStatus ||
						Move.Roll == USAttributes.PowerStatus || Move.Roll == USAttributes.VeilStatus)
				{
					<div class="RollDetails">(Estatus)</div>
				}
				else if (Move.Roll == USAttributes.Mortality || Move.Roll == USAttributes.Night ||
						Move.Roll == USAttributes.Power || Move.Roll == USAttributes.Veil)
				{
					<div class="RollDetails">(Circulo)</div>
				}
				else
				{
					<div class="RollDetails">(@Move.Roll.ToUI().ToLower()@rollNumber)</div>
				}
				
			}			
		</div>
		<div class="ImagesContainer">
			@if(Move.IsImprovedByOtherMove)
			{
				<i class="bi bi-fire" style="color: #675704;"></i>
			}
			<img src="imgs/Icons/UpgradedArrow.png" class="@(Move.IsImproved?"IconSize":"Hidden")" />
			<img src="imgs/Icons/TicksCircleIcon.png" class="@(Move.TicksCircle?"IconSize":"Hidden")" />
			
			@if (!IsSelectionMode || !IsSelected)
			{
				if (Move.HasRoll() && !MasterView )
				{
					<img class="DiceButton"
						 src="imgs/Icons/Dice.svg" 
						@onclick=@(async ()=>{await Roll();}) 
						@onclick:stopPropagation=true/>
				}
				else
				{
					<img src="imgs/DW/TalkIcon.png" style="filter:invert(1); width:26px!important; height:26px!important;" />
				}
			}
			else
			{
				@if(Player.SelectedArchetypeMoves.Contains(Move.ID) || 
					Player.SelectedCorruptionMoves.Contains(Move.ID))
				{
					<img src="imgs/Icons/Remove.svg" @onclick=@(_=>{SelectedInSelectionMode.InvokeAsync(Move);}) />
				}
				else
				{
					<img src="imgs/Icons/Add.svg" style="opacity: 0.75;" @onclick=@(_=>{SelectedInSelectionMode.InvokeAsync(Move);})/>
				}
			}
		</div>
	</div>
	<div class="MoveBody flex-column">
		@if (Move.ID == USMoveIDs.B_LiberarPoder)
		{
			<DecodedString Value="@Move.PreCondition.MainText" />

			<div class="LIOContainer d-flex flex-column">
				@if(MasterView)
				{
					<div class="LIOBox">Pregunta al jugador que habilidad utiliza</div>
				}
				else
				{
					@foreach (var lio in Player.LIOs)
					{
						<div class="LIOBox">
							@Moves.AllLio.Find(x=>x.ID == lio)?.Text
						</div>
					}
					<div class="d-flex justify-content-center w-100">
						<button class="btn btn-outline-light w-75 opacity-75 mt-3" @onclick=SelectNewLIOMove>Añadir habilidad</button>
					</div>
				}				
			</div>

			<div class="Advanced @(Move.IsImproved?"AdvancedYEs":"AdvancedNOT") @(MasterView ? "AdvancedYEs" : "")" @onclick=AdvanceClicked>
				<div class="px-2"><img src="imgs/Icons/UpgradedArrow@(Move.IsImproved?"":"NO").png" /></div>
				<div class="AdvancedMainText">
					<DecodedString Value="@Move.AdvancedConsequences.MainText" />
					@if (Move.AdvancedConsequences.Options != null)
					{
						<ul class="mt-1">
							@foreach (var item in Move.AdvancedConsequences.Options)
							{
								<li><DecodedString Value="@item" /></li>
							}
						</ul>						
					}
				</div>
			</div>

		}
		else
		{
			<DecodedString Value="@Move.PreCondition.MainText"/>		
			@if (Move.PreCondition.Options != null)
			{
				<ul class="mt-1">
					@foreach (var item in Move.PreCondition.Options)
					{
						<li><DecodedString Value="@item"/></li>
					}
				</ul>
			}	
			@if (Move.ConsequencesOn79 != null)
			{
				<div class="@(MasterView && MasterRolledValue >= 7 && MasterRolledValue <= 9? "MasterSelected orange" : "")">
					<DecodedString Value="@Move.ConsequencesOn79.MainText" />
					@if (Move.ConsequencesOn79.Options != null)
					{
						<ul class="mt-1">
							@foreach (var item in Move.ConsequencesOn79.Options)
							{
								<li><DecodedString Value="@item" /></li>
							}
						</ul>
					}
				</div>
			}
			@if (Move.ConsequencesOn10 != null)
			{
				<div class="@(MasterView && MasterRolledValue >= 10 ? "MasterSelected green" : "")">
					<DecodedString Value="@Move.ConsequencesOn10.MainText" />
					@if (Move.ConsequencesOn10.Options != null)
					{
						<ul class="mt-1">
							@foreach (var item in Move.ConsequencesOn10.Options)
							{
								<li><DecodedString Value="@item" /></li>
							}
						</ul>
					}
				</div>
			}

			@if (Move.ConsequencesOn6 != null)
			{
				<div class="@(MasterView && MasterRolledValue <= 6 ? "MasterSelected red" : "")">
					<DecodedString Value="@Move.ConsequencesOn6.MainText" />
					@if (Move.ConsequencesOn6.Options != null)
					{
						<ul class="mt-1">
							@foreach (var item in Move.ConsequencesOn6.Options)
							{
								<li><DecodedString Value="@item" /></li>
							}
						</ul>
					}
				</div>
			}

			@if (Move.TypeOfMovement == MovementTypes.BasicMovements &&
					Move.AdvancedConsequences is not null &&
					Move.AdvancedConsequences.MainText is not null &&
					Move.AdvancedConsequences.MainText != "")
			{
				<div class="Advanced @(Move.IsImproved?"AdvancedYEs":"AdvancedNOT") @(MasterView ? "AdvancedYEs" : "")">
					<div class="px-2"><img src="imgs/Icons/UpgradedArrow@(Move.IsImproved?"":"NO").png" /></div>
					<div class="AdvancedMainText">
						<DecodedString Value="@Move.AdvancedConsequences.MainText" />
						@if (Move.AdvancedConsequences.Options != null)
						{
							<ul class="mt-1">
								@foreach (var item in Move.AdvancedConsequences.Options)
								{
									<li><DecodedString Value="@item" /></li>
								}

							</ul>
						}
					</div>
				</div>
			}

			@if(Move.IsImprovedByOtherMove)
			{
				<div class="ImproveBox d-flex gap-1">
					<div>
						<i class="bi bi-fire" style="color: #675704;"></i>
					</div>
					<div class="d-flex flex-column">
						@foreach (var s in Move.ImprovedByOhterMoveExplanation)
						{
							<DecodedString Value="@s"/>
						}
					</div>
				</div>
			}

			<div class="d-flex flex-wrap gap-1 justify-content-center mt-3">
				@foreach(var s in Move.Rolls.Where(x=>x != USAttributes.None))
				{
					<div class="RollButton d-flex flex-column"
							@onclick=@(async()=>{ await RollDirect(s);})
							@onclick:stopPropagation=true>
						<div>@s.ToUI()</div>
						@if (s != USAttributes.just10 && s != USAttributes.just13 && s != USAttributes.just5)
						{
							<div>(@Player.GetAttribute(s).ToNiceUIStat())</div>
						}
					</div>
				}
			</div>
		}
		
	</div>
</div>
<!--Advacnce movement modal-->
<div class="FullScreenModal @(IsShowingFullScreenModal?"":"HideModal")" @onclick=CloseFullScreenModal>
	<div class="ModalBody">
		<p>Ahora mismo <strong>@Move.Title</strong> está <span style="font-weight:bold;">@(Move.IsImproved ? "Avanzado" : "Normal")</span></p>
		<p class="mt-4 mb-1">Como dejamos el movimiento?</p>
		<div class="d-flex gap-2">
			<button class="btn btn-outline-light" style="width: 50%;" @onclick=MakeMoveNOTAdvanced @onclick:stopPropagation=true>Movimiento normal</button>
			<button class="btn btn-outline-light" style="width: 50%;" @onclick=MakeMoveAdvanced @onclick:stopPropagation=true>
				<img src="imgs/Icons/UpgradedArrow.png"/> Avanzado
				</button>
		</div>		
	</div>
</div>

<!--Add lio modal-->
<div class="FullScreenModal @(IsSLioSelectingModalON?"":"HideModal")" @onclick=CloseLIOSelectionModal>
	<div class="w-100 d-flex justify-content-end p-2">
		<img src="imgs/Icons/Close.svg" style="cursor: pointer;" />
	</div>
	<div class="ModalBody w-100">
		<div class="accordion accordion-flush w-100 DarkAccordion" @onclick:stopPropagation=true id="accordionFlushExample">
		@foreach (var pack in LIOs)
		{
			<div class="accordion-item w-100 accordionMovement DarkAccordionItem @(pack == SelectedPack?"":"DarkAccordionNotSelected")">
				<h2 class="accordion-header w-100 DarkAccordionHeader" id="flush-headingOne-@pack.Habilities[0].ToString()">
					<div data-bs-toggle="collapse" class="text-light"
						 data-bs-target="#flush-collapseOne-@pack.Habilities[0].ToString()"
					     @onclick=@(_ =>{SelectedPack = pack;})>
						@pack.Tittle
					</div>

				</h2>
				<div id="flush-collapseOne-@pack.Habilities[0].ToString()" class="accordion-collapse collapse @(pack == SelectedPack?"show":"") DarkAccordionBody" aria-labelledby="flush-headingOne" data-bs-parent="flush-headingOne-@pack.Habilities[0].ToString()">
					<div class="Darker d-flex flex-column flex-column gap-3">
						@foreach (var hability in pack.Habilities)
						{
							<div class="text-light d-flex w-100 justify-content-between gap-3" >
								@Moves.AllLio.Find(x=>x.ID == hability).Text
								@if(Player.LIOs.Contains(hability))
								{
									<img src="imgs/Icons/Remove.svg" width="25" style="cursor:pointer;"@onclick=@(async _=> {await ToggleLIO(hability);})/>
								}
								else
								{
									<img src="imgs/Icons/Add.svg" width="25" style="cursor:pointer;" @onclick=@(async _=> {await ToggleLIO(hability);}) />
								}
							</div>
						}
					</div>
				</div>
			</div>
		}
		</div>
	</div>
</div>

<!--ChooseCircle modal-->
<div class="FullScreenModal @(IsShowingStatSelectionModal?"":"HideModal")" @onclick=CloseStatSelectionModal>
	<div class="ModalBody">
		<p>Elija círculo para tirar los dados</p>
		<div class="d-flex flex-wrap gap-1">
			@foreach(var r in Move.Rolls)
			{
				<button class="btn btn-outline-light" style="width: 100px;"
						@onclick=@(()=>{SelectStat(r);})
						@onclick:stopPropagation=true>
					@r.ToUI()
				</button>
			}
			
		</div>
		<div>
			@foreach (var r in Move.ImprovedByOhterMoveExplanation)
			{
				<DecodedString Value="@r" />
			}
		</div>
		@*< div class="d-flex gap-2">
			<div class="d-flex flex-column gap-2">
				<button class="btn btn-outline-light" style="width: 100px;"
						@onclick=@(()=>{SelectCircle(USAttributes.Mortality);})
						@onclick:stopPropagation=true>
					Mortalis
				</button>
				<button class="btn btn-outline-light" style="width: 100px;"
						@onclick=@(()=>{SelectCircle(USAttributes.Night);})
						@onclick:stopPropagation=true>
					Noche
				</button>
			</div>
			<div class="d-flex flex-column gap-2">
				<button class="btn btn-outline-light" style="width: 100px;"
						@onclick=@(()=>{SelectCircle(USAttributes.Power);})
						@onclick:stopPropagation=true>
					Poder
				</button>
				<button class="btn btn-outline-light" style="width: 100px;"
						@onclick=@(()=>{SelectCircle(USAttributes.Veil);})
						@onclick:stopPropagation=true>
					Velo
				</button>
			</div>
		</div> *@
	</div>
</div>

@code {
	[Parameter] public USMoveIDs ID { get; set; }
	[Parameter] public bool IsSelected { get; set; }
	[Parameter] public EventCallback<USMove> Clicked { get; set; }
	[Parameter] public bool IsSelectionMode { get; set; }
	[Parameter] public EventCallback<USMove> SelectedInSelectionMode { get; set; }
	[Parameter] public EventCallback ForceUpdate{ get; set; }
	[Parameter] public bool MasterView { get; set; } = false;
	[Parameter] public int MasterRolledValue { get; set; }
	[Parameter] public USCharacterSheet Player { get; set; }
	[Parameter] public IMove? imove { get; set; } = null;
	[Parameter] public EventCallback FinishedRolling { get; set; }
	USMove Move;

	string rollNumber
	{
		get
		{
			if (Move.CanBeRolledAutomatically)
			{
				return " " + Player.GetAttribute(Move.Roll).ToString();
			}
			else
				return "";
		}
	}

	public void Select()
	{
		IsSelected = true;
	}
	public void UnSelect() => IsSelected = false;

	bool AlreadyFixed = false;
	IMove? CurrentMove = null;

	private bool IsRollMixed(List<USAttributes> rolls)
	{
		var targetAttributes = new List<USAttributes> { USAttributes.Blood, USAttributes.Heart, USAttributes.Soul, USAttributes.Mind };

		// Contamos cuántos de esos atributos específicos están en la lista de 'rolls'
		int count = rolls.Where(roll => targetAttributes.Contains(roll)).Count();

		// Verificamos si hay al menos dos
		return count >= 2;
	}

	protected override void OnParametersSet()
	{
		USMove temp = new USMove(USMoveIDs.NotSet, USAttributes.None);

		if (imove is not null)
			temp = (USMove)imove;
		else
		{
			temp = Moves.AllMovements.Find(x => x.ID == ID);
		}


		if (temp is null)
		{
			Toaster.ShowError($"The move {ID} is not in the DB");
		}
		else
		{
			if(CurrentMove != temp ||  !AlreadyFixed)
			{
				Move = Moves.GenerateImprovedMovement(temp, Player);
				AlreadyFixed = true;
			}
		}

		CurrentMove = Move;

		StateHasChanged();
	}

	private void PointerDown() => Clicked.InvokeAsync(Move);

	public void Edit()
	{
		if (Move.TypeOfMovement == MovementTypes.BasicMovements)
			OpenFullScreenModal();
		else
			Toaster.ShowInfo("Solo se pueden avanzar movimientos básicos.");
	}

	bool IsShowingFullScreenModal = false;
	private void OpenFullScreenModal() => IsShowingFullScreenModal = true;
	private void CloseFullScreenModal() => IsShowingFullScreenModal = false;

	private class LIOsPack
	{
		public string Tittle {get;set;} ="";
		public List<USMoveIDs> Habilities {get;set;}=new();
	}
	List<LIOsPack> LIOs = new();
	LIOsPack SelectedPack = new();
	bool IsSLioSelectingModalON = false;
	private void OpenLIOSelectionModal() { 
		IsSLioSelectingModalON = true;
		LIOs.Clear();
		foreach (var arc in Enum.GetValues(typeof(US_Classes)).Cast<US_Classes>())
		{
			if (arc != US_Classes.All && arc != US_Classes.NotSet && arc != Player.Archetype)
			{
				LIOs.Add(new LIOsPack
					{
						Tittle = arc.ToUI(),
						Habilities = (from l in Moves.AllLio where l.Archetype == arc select l.ID).ToList()
					});
			}
		}
	}
	private void CloseLIOSelectionModal() => IsSLioSelectingModalON = false;
	private async Task ToggleLIO(USMoveIDs lioId)
	{
		if (Player.LIOs.Contains(lioId))
			Player.LIOs.Remove(lioId);
		else
			Player.LIOs.Add(lioId);
		await Game.StoreChangesOnCharacter(Player, "actualizó sus poderes de dejarlo salir");
		await ForceUpdate.InvokeAsync();
	}

	async Task AdvanceClicked()
	{
		if (Move.IsImproved) await MakeMoveNOTAdvanced();
		else await MakeMoveAdvanced();
	}

	async Task MakeMoveAdvanced()
	{
		if (Move.IsImproved) CloseFullScreenModal();
		else
		{
			Move.IsImproved = true;
			Player.UpgradedMoves.Add(Move.ID);
			await Game.StoreChangesOnCharacter(Player, "añadió movimientos avanzados");
			//CloseFullScreenModal();
		}
	}
	async Task MakeMoveNOTAdvanced()
	{
		if (!Move.IsImproved) CloseFullScreenModal();
		else
		{
			Move.IsImproved = false;
			Player.UpgradedMoves.Remove(Move.ID);
			await Game.StoreChangesOnCharacter(Player, "eliminó movimientos avanzados");
			//CloseFullScreenModal();
		}
	}

	Random rnd = new();

	async Task Roll()
	{
		int bonus = 0;
		string rollText = "";

		if(Move.Rolls.Count > 1)
		{
			// OpenStatSelectionModal();
			// var stat = await WaitForUserToChoseCircle();
			// CloseStatSelectionModal();
			// bonus = Player.GetAttribute(stat);
			// rollText = stat.ToUI();

			// Game.Roll(Player.ID, Move, stat, Move.ID, bonus, RollTypes.Roll_Simple, rollText);
			PointerDown();
		}
		else
		{			
			bonus = Player.GetAttribute(Move.Roll);
			rollText = Move.Roll.ToUI();
			Game.Roll(Player.ID, Move, Move.Roll, Move.ID, bonus, RollTypes.Roll_Simple, rollText);
		}

		await FinishedRolling.InvokeAsync();
	}

	async Task RollDirect(USAttributes stat)
	{
		var bonus = Player.GetAttribute(stat);
		var rollText = stat.ToUI();
		Game.Roll(Player.ID, Move, stat, Move.ID, bonus, RollTypes.Roll_Simple, rollText);
		await FinishedRolling.InvokeAsync();
	}

	bool IsShowingStatSelectionModal = false;
	void CloseStatSelectionModal() => IsShowingStatSelectionModal = false;
	void OpenStatSelectionModal() => IsShowingStatSelectionModal = true;

	USAttributes SelectedCircle = USAttributes.None;
	TaskCompletionSource<USAttributes> tcs = new();
	private Task<USAttributes> WaitForUserToChoseCircle()
	{
		tcs = new();
		return tcs.Task;
	}

	void SelectStat(USAttributes at) => tcs.SetResult(at);

	private async Task SelectNewLIOMove()
	{
		List<MoveSelector.MovesPack> options = new();

		MoveSelector.MovesPack firstOption = new();
		firstOption.Title = Player.Archetype.ToUI();
		foreach (var m in Moves.AllLio.Where(
			x => x.Archetype == Player.Archetype))
		{
			MoveSelector.MovesPackItem item = new();
			if (Player.LIOs.Contains(m.ID))
				item.IsAlreadySelected = true;
			else
				item.IsAlreadySelected = false;

			item.move = m;
			firstOption.Moves.Add(item);
		}
		options.Add(firstOption);

		foreach (US_Classes arc in Enum.GetValues(typeof(US_Classes)))
		{
			if (arc == Player.Archetype) continue;
			if (arc == US_Classes.All) continue;
			if (arc == US_Classes.NotSet) continue;

			firstOption = new();
			firstOption.Title = arc.ToUI();
			foreach (var m in Moves.AllLio.Where(
				x => x.Archetype == arc))
			{
				MoveSelector.MovesPackItem item = new();
				if (Player.LIOs.Contains(m.ID))
					item.IsAlreadySelected = true;
				else
					item.IsAlreadySelected = false;

				item.move = m;
				firstOption.Moves.Add(item);
			}

			options.Add(firstOption);
		}


		await MSelector.StartSelection(options);

		Player.LIOs.Clear();

		foreach (var option in options)
		{
			foreach (var move in option.Moves)
			{
				if (move.IsAlreadySelected)
				{
					var m = move.move as LIO;
					Player.LIOs.Add(m.ID);
				}

			}
		}

		await Game.StoreChangesOnCharacter(Player, "Actualizó sus movimientos de dejarlo salir");
		StateHasChanged();
	}
}
